package server;import com.fasterxml.jackson.databind.ObjectMapper;import exceptions.FaRAlreadyConnectedClient;import exceptions.FaRIllegalDataException;import exceptions.FaRWrongDataBase;import exceptions.FlightAndRouteException;import javafx.collections.ListChangeListener;import javafx.util.Pair;import model.*;import org.jetbrains.annotations.NotNull;import reactor.core.publisher.Flux;import reactor.core.publisher.FluxSink;import settings.Base;import settings.Settings;import settings.SettingsManager;import settings.User;import transport.Data;import transport.ListChangeAdapter;import transport.UserInformation;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.*;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.locks.ReentrantReadWriteLock;import java.util.function.Predicate;import java.util.stream.Collectors;import java.util.stream.Stream;import static settings.SettingsManager.basesCacheFiles;public class Server{    public static final Settings settings;    //    contains all login of connected read clients    private static final List<String>              connectedClients = new ArrayList<>();    private static final ReentrantReadWriteLock    clientsLock      = new ReentrantReadWriteLock( true );    //    contains all connectedAdmins with their socket who is already connected    private static final Map<String, OutputStream> connectedAdmins  = new ConcurrentHashMap<>();    private static final ReentrantReadWriteLock    adminsLock       = new ReentrantReadWriteLock( true );    @SuppressWarnings( "FieldCanBeLocal" ) private static Integer port;    @SuppressWarnings( "FieldCanBeLocal" ) private static Integer stoppingPort;    static{        settings = SettingsManager.loadSettings();    }    @SuppressWarnings( "InfiniteLoopStatement" )    public static void main( String[] args ) throws IOException{        port = Integer.parseInt( args[ 0 ] );//        handler stop server action from settings app        stoppingPort = Integer.parseInt( args[ 1 ] );        AtomicBoolean           stopped        = new AtomicBoolean( false );        AtomicReference<Socket> stoppingSocket = new AtomicReference<>( new Socket() );        Executors.newSingleThreadExecutor().submit( () -> {            try( ServerSocket serverSocket = new ServerSocket( stoppingPort ) ){                stoppingSocket.set( serverSocket.accept() );                stopped.set( true );            }catch( IOException e ){                e.printStackTrace();            }        } );        try( ServerSocket requestServerSocket = new ServerSocket( port ) ){//            Cleaning old cache files            Executors.newSingleThreadScheduledExecutor( r -> {                Thread thread = new Thread( r );                thread.setDaemon( true );                return thread;            } ).scheduleAtFixedRate( () -> {                try( Stream<Path> pathStream = Files.find( Paths.get( basesCacheFiles ) ,                                                           1 ,                                                           ( path , basicFileAttributes ) -> basicFileAttributes.isRegularFile() &&                                                                                             basicFileAttributes.lastAccessTime()                                                                                                                .toInstant()                                                                                                                .getEpochSecond() >=                                                                                             30 ) ){                    for( Path path : pathStream.collect( Collectors.toList() ) ){                        Files.delete( path );                    }                }catch( IOException e ){                    e.printStackTrace();                }            } , 30 , 30 , TimeUnit.SECONDS );//            Request threads            ExecutorService requestService = Executors.newCachedThreadPool();            while( true ){//                Server stops only after new connection                if( stopped.get() ){                    try( DataOutputStream dataOutputStream = new DataOutputStream( stoppingSocket.get()                                                                                                 .getOutputStream() ) ){                        dataOutputStream.writeUTF( "Server stopped" );                    }                    System.exit( 0 );                }                requestService.execute( new RequestParser( requestServerSocket.accept() ) );            }        }    }    static class RequestParser implements Runnable{        private final Socket socket;        private final ObjectMapper mapper = new ObjectMapper();        private DataInputStream  inputStream;        private DataOutputStream outputStream;        private DataModel        dataModel;        RequestParser( Socket socket ) throws IOException{            this.socket = socket;            try{                this.outputStream = new DataOutputStream( socket.getOutputStream() );                this.inputStream = new DataInputStream( socket.getInputStream() );            }catch( IOException e ){                e.printStackTrace();                socket.close();            }        }        @Override        public void run(){            try{                UserInformation                        userInformation =                        mapper.readerFor( UserInformation.class ).readValue( inputStream.readUTF() );//                Request for bases list                if( userInformation.getDataBase() == null ){                    outputStream.writeUTF( mapper.writeValueAsString( databasesListRequest( userInformation ) ) );                    closeConnection();                    return;                }//                finding any database with specified user                Optional<Pair<Base, User>> optionalBase = getDatabaseWithUser( userInformation );                if( optionalBase.isPresent() ){                    final Pair<Base, User> configs = optionalBase.get();                    clientsLock.readLock().lock();                    boolean                            alreadyConnected =                            connectedClients.stream().anyMatch( Predicate.isEqual( userInformation.getLogin() ) );                    clientsLock.readLock().unlock();                    if( alreadyConnected ){                        /* Refuse client's request, if the same login already works with server                         * Admins can make several connections for server*/                        sendError( new FaRAlreadyConnectedClient( String.format(                                "Client %s is already connected. Connection refused." ,                                userInformation.getLogin() ) ) );                        closeConnection();                        return;                    }                    dataModel =                            DataModelInstanceSaver.getInstance( configs.getKey().getName() )                                                  .map( DataModelWithLockAndListener::getModel )                                                  .orElseThrow( IllegalStateException::new );                    switch( configs.getValue().getPrivilege() ){                        case ReadWrite:                            adminsLock.writeLock().lock();                            connectedAdmins.put( userInformation.getLogin() , outputStream );                            adminsLock.writeLock().unlock();                            outputStream.writeUTF( mapper.writeValueAsString( getStartingData( userInformation ) ) );                            ListChangeListener<Route>                                    routeChange =                                    change -> sendChange( ListChangeAdapter.routeChange( change ) );                            ListChangeListener<Flight>                                    flightChange =                                    change -> sendChange( ListChangeAdapter.flightChange( change ) );                            dataModel.addRoutesListener( routeChange );                            dataModel.addFlightsListener( flightChange );                            Flux.create( this::listenUpdateFromClients )                                .map( this::userRequestToUserInformation )                                .groupBy( this::getClientRequestType )                                .doOnNext( request -> {                                    switch( request.key() ){                                        case Change:                                            request.map( UserInformation::getChanges )                                                   .flatMapSequential( Flux::fromIterable )                                                   .subscribe( this::applyUsersUpdateRequest );                                            break;                                        case Upload:                                            request.subscribe( this::uploadDataAgainWithPredicate );                                            break;                                    }                                } )                                .doFinally( signalType -> cleatAfterAdmin( userInformation ,                                                                           routeChange ,                                                                           flightChange ) )                                .blockLast();                            break;                        case Read:                            clientsLock.writeLock().lock();                            connectedClients.add( userInformation.getLogin() );                            clientsLock.writeLock().unlock();                            Data response = new Data();                            try( Stream<Path> pathStream = Files.find( Paths.get( basesCacheFiles ) ,                                                                       1 ,                                                                       ( path , basicFileAttributes ) -> {                                                                           return basicFileAttributes.isRegularFile() &&                                                                                  path.getFileName()                                                                                      .toString()                                                                                      .equals( configs.getKey()                                                                                                      .getName() +                                                                                               "_" +                                                                                               configs.getValue()                                                                                                      .getLogin() );                                                                       } ) ){                                final Optional<Path> cachingFile = pathStream.findFirst();                                if( cachingFile.isPresent() ){                                    response.setChanges( Files.lines( cachingFile.get() )                                                              .map( ListChangeAdapter::new )                                                              .collect( Collectors.toList() ) );                                    Files.write( cachingFile.get() , "".getBytes() );                                }else{                                    Files.createFile( Paths.get( basesCacheFiles +                                                                 configs.getKey().getName() +                                                                 "_" +                                                                 configs.getValue().getLogin() ) );                                    response = getStartingData( userInformation );                                }                            }                            outputStream.writeUTF( mapper.writeValueAsString( response ) );                            clientsLock.writeLock().lock();                            connectedClients.remove( userInformation.getLogin() );                            clientsLock.writeLock().unlock();                            closeConnection();                            break;                    }                }else{                    sendError( new FaRWrongDataBase( String.format( "Server doesn't contain database %s for user %s" ,                                                                    userInformation.getDataBase() ,                                                                    userInformation.getLogin() ) ) );                    closeConnection();                }            }catch( IOException e ){                e.printStackTrace();            }        }        @NotNull        private Server.RequestParser.ClientRequestTypes getClientRequestType( UserInformation request ){            if( request.getChanges() != null ){                return ClientRequestTypes.Change;            }else if( request.getPredicate() != null && request.getChanges() == null ){                return ClientRequestTypes.Upload;            }else{                throw new IllegalArgumentException( "Wrong request type" );            }        }        enum ClientRequestTypes{            Change,            Upload        }        @NotNull        private Data getStartingData( UserInformation userInformation ){            Data data = new Data( dataModel.getRouteObservableList() , dataModel.getFlightObservableList() );            //noinspection unchecked            Optional.ofNullable( userInformation.getPredicate() ).ifPresent( predicateParser -> {                predicateParser.ifRoutePredicateOrFlightPredicate( routePredicate -> {                    data.setRoutes( dataModel.getRouteObservableList().filtered( routePredicate ) );                    data.setFlights( dataModel.getFlightObservableList()                                              .filtered( flight -> data.getRoutes().contains( flight.getRoute() ) ) );                } , flightPredicate -> dataModel.getFlightObservableList().filtered( flightPredicate ) );            } );            return data;        }        private void uploadDataAgainWithPredicate( UserInformation uploadRequest ){            Data data = new Data();            try{                if( uploadRequest.getPredicate().isRoutePredicate() ){                    data.setRoutes( dataModel.getRouteObservableList()                                             .filtered( uploadRequest.getPredicate().getRoutePredicate() ) );                    data.setFlights( dataModel.getFlightObservableList()                                              .filtered( flight -> data.getRoutes().contains( flight.getRoute() ) ) );                }else{                    data.setFlights( dataModel.getFlightObservableList()                                              .filtered( uploadRequest.getPredicate().getFlightPredicate() ) );                }                outputStream.writeUTF( mapper.writeValueAsString( data ) );            }catch( FlightAndRouteException e ){                data.setException( e );            }catch( IOException e ){                throw new IllegalStateException( "Upload exception" , e );            }        }        private void applyUsersUpdateRequest( ListChangeAdapter change ){            try{                change.apply( dataModel , true );            }catch( FlightAndRouteException e ){                sendError( e );            }        }        private void listenUpdateFromClients( FluxSink<String> emitter ){            try{                String req;                while( !( req = inputStream.readUTF() ).equals( "*" ) ){                    emitter.next( req );                }                emitter.complete();            }catch( EOFException e ){                emitter.complete();            }catch( IOException e ){                emitter.error( e );            }        }        private void cleatAfterAdmin( UserInformation userInformation ,                                      ListChangeListener<Route> routeChange ,                                      ListChangeListener<Flight> flightChange ){            dataModel.removeRoutesListener( routeChange );            dataModel.removeFlightsListener( flightChange );            connectedAdmins.remove( userInformation.getLogin() );            closeConnection();        }        private UserInformation userRequestToUserInformation( String string ){            try{                return mapper.readerFor( UserInformation.class ).readValue( string );            }catch( IOException e ){                throw new IllegalStateException( "Exception while reading info from user" );            }        }        /**         Returns database, that user has requested with his privileges. Optional empty if settings file doesn't         contain specified database         @param userInformation user request info         @return Optional.of(Base , User) , if user and base info is right, Optional.empty() instead         */        private Optional<Pair<Base, User>> getDatabaseWithUser( UserInformation userInformation ){            //noinspection ConstantConditions            return settings.getBase()                           .parallelStream()                           .filter( base -> base.getName().equals( userInformation.getDataBase() ) )                           .map( base -> getFirstBaseWithSpecifiedUser( base ,                                                                        userInformation.getLogin() ,                                                                        userInformation.getPassword() ) )                           .filter( pair -> pair.getValue().isPresent() )                           .map( pair -> new Pair<>( pair.getKey() , pair.getValue().get() ) )                           .findFirst();        }        @NotNull        private Pair<Base, Optional<User>> getFirstBaseWithSpecifiedUser( Base base , String login , String password ){            return new Pair<>( base ,                               base.getUsers()                                   .parallelStream()                                   .filter( user -> userPredicate( user , login , password ) )                                   .findFirst() );        }        private Data databasesListRequest( UserInformation userInformation ){            Data response = new Data();//            collecting databases with privileges of specified client            response.setBases( settings.getBase()                                       .parallelStream()                                       .map( base -> getFirstBaseWithSpecifiedUser( base ,                                                                                    userInformation.getLogin() ,                                                                                    userInformation.getPassword() ) )                                       .filter( pair -> pair.getValue().isPresent() )                                       .map( pair -> new Pair<>( pair.getKey().getName() ,                                                                 pair.getValue().get().getPrivilege().name() ) )                                       .collect( Collectors.toMap( Pair::getKey , Pair::getValue ) ) );            return response;        }        private void sendError( FlightAndRouteException e ){            try{                Data response = new Data();                response.setException( new FaRIllegalDataException( e.getMessage() , e.getCause() ) );                outputStream.writeUTF( mapper.writeValueAsString( response ) );            }catch( IOException e1 ){                e1.printStackTrace();            }        }        private void closeConnection(){            try{                outputStream.close();                inputStream.close();                socket.close();            }catch( IOException e ){                e.printStackTrace();            }        }        private void sendChange( ListChangeAdapter adapter ){            Data data = new Data();            data.setChanges( Collections.singletonList( adapter ) );            adminsLock.readLock().lock();//            Send changes to all admins            connectedAdmins.entrySet()                           .stream()                           .map( Map.Entry::getValue )                           .map( DataOutputStream.class::cast )                           .forEach( outputStream -> {                               try{                                   outputStream.writeUTF( mapper.writeValueAsString( data ) );                               }catch( IOException e ){                                   e.printStackTrace();                               }                           } );            adminsLock.readLock().unlock();        }        private boolean userPredicate( User user , String login , String password ){            return user.getLogin().equals( login ) && user.getPassword().equals( password );        }    }}