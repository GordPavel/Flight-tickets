package server;import com.fasterxml.jackson.databind.ObjectMapper;import exceptions.FaRAlreadyConnectedClient;import exceptions.FaRIllegalDataException;import exceptions.FaRWrongDataBase;import exceptions.FlightAndRouteException;import javafx.collections.ListChangeListener;import javafx.util.Pair;import model.*;import org.jetbrains.annotations.NotNull;import reactor.core.publisher.Flux;import reactor.core.publisher.FluxSink;import settings.Base;import settings.Settings;import settings.SettingsManager;import settings.User;import transport.Data;import transport.ListChangeAdapter;import transport.UserInformation;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.time.Duration;import java.time.Instant;import java.time.LocalDateTime;import java.time.ZoneId;import java.util.*;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantReadWriteLock;import java.util.function.Predicate;import java.util.stream.Collectors;import java.util.stream.Stream;import static settings.SettingsManager.basesCacheFiles;public class Server{    public static final                                   Settings settings;    @SuppressWarnings( "FieldCanBeLocal" ) private static Integer  port;    static{        settings = SettingsManager.loadSettings();    }    //    contains all login of connected read clients    private static final List<String>           connectedClients = new ArrayList<>();    private static final ReentrantReadWriteLock clientsLock      = new ReentrantReadWriteLock( true );    //    contains all connectedAdmins with their socket who is already connected    private static final Map<String, OutputStream> connectedAdmins = new ConcurrentHashMap<>();    private static final ReentrantReadWriteLock    adminsLock      = new ReentrantReadWriteLock( true );    @SuppressWarnings( "InfiniteLoopStatement" )    public static void main( String[] args ) throws IOException{        port = Integer.parseInt( args[ 0 ] );        try( ServerSocket requestServerSocket = new ServerSocket( port ) ){            Executors.newSingleThreadScheduledExecutor( r -> {                Thread thread = new Thread( r );                thread.setDaemon( true );                return thread;            } ).scheduleAtFixedRate( () -> {                try{                    Files.list( Paths.get( basesCacheFiles ) ).filter( Server::isLastAgoModified ).forEach( path -> {                        try{                            Files.delete( path );                        }catch( IOException e ){                            e.printStackTrace();                        }                    } );                }catch( IOException e ){                    e.printStackTrace();                }            } , 1 , 1 , TimeUnit.DAYS );//            Request threads            ExecutorService requestService = Executors.newCachedThreadPool();            while( true ){                requestService.execute( new RequestParser( requestServerSocket.accept() ) );            }        }    }    private static boolean isLastAgoModified( Path path ){        return Duration.between( LocalDateTime.ofInstant( Instant.ofEpochMilli( path.toFile().lastModified() ) ,                                                          ZoneId.systemDefault() ) , LocalDateTime.now() ).toDays() >=               1;    }    static class RequestParser implements Runnable{        private final Socket           socket;        private       DataInputStream  inputStream;        private       DataOutputStream outputStream;        private final ObjectMapper mapper = new ObjectMapper();        RequestParser( Socket socket ) throws IOException{            this.socket = socket;            try{                this.outputStream = new DataOutputStream( socket.getOutputStream() );                this.inputStream = new DataInputStream( socket.getInputStream() );            }catch( IOException e ){                e.printStackTrace();                socket.close();            }        }        @Override        public void run(){            try{                UserInformation userInformation =                        mapper.readerFor( UserInformation.class ).readValue( inputStream.readUTF() );                if( userInformation.getDataBase() == null ){                    outputStream.writeUTF( mapper.writeValueAsString( databasesListRequest( userInformation ) ) );                    closeConnection();                    return;                }//                finding any database with specified user                Optional<Pair<Base, User>> optionalBase = getDatabaseWithUser( userInformation );                if( optionalBase.isPresent() ){                    clientsLock.readLock().lock();                    adminsLock.readLock().lock();                    boolean alreadyConnected =                            Stream.concat( connectedClients.stream() , connectedAdmins.keySet().stream() )                                  .anyMatch( Predicate.isEqual( userInformation.getLogin() ) );                    clientsLock.readLock().unlock();                    adminsLock.readLock().unlock();                    if( alreadyConnected ){                        sendError( new FaRAlreadyConnectedClient(                                String.format( "Client %s is already connected. Connection refused." ,                                               userInformation.getLogin() ) ) );                        closeConnection();                        return;                    }                    switch( optionalBase.get().getValue().getPrivilege() ){                        case ReadWrite:                            adminsLock.writeLock().lock();                            connectedAdmins.put( userInformation.getLogin() , outputStream );                            adminsLock.writeLock().unlock();                            DataModelWithLockAndListener adminDataModel =                                    DataModelInstanceSaver.getInstance( userInformation.getDataBase() )                                                          .orElseThrow( IllegalStateException::new );                            outputStream.writeUTF( mapper.writeValueAsString(                                    getStartingData( userInformation , adminDataModel.getModel() ) ) );                            ListChangeListener<Route> routeChange =                                    change -> sendChange( ListChangeAdapter.routeChange( change ) );                            ListChangeListener<Flight> flightChange =                                    change -> sendChange( ListChangeAdapter.flightChange( change ) );                            adminDataModel.getModel().addRoutesListener( routeChange );                            adminDataModel.getModel().addFlightsListener( flightChange );                            Flux.create( this::listenUpdateFromClients ).<UserInformation> map( string -> {                                try{                                    return mapper.readerFor( UserInformation.class ).readValue( string );                                }catch( IOException e ){                                    throw new IllegalStateException( "Exception while reading info from user" );                                }                            } ).map( UserInformation::getChanges )                               .doOnNext( listChanges -> {                                   adminsLock.writeLock().lock();                                   listChanges.forEach( change -> {                                       try{                                           change.apply( adminDataModel.getModel() );                                       }catch( FlightAndRouteException e ){                                           sendError( e );                                       }                                   } );                                   adminsLock.writeLock().unlock();                               } )                               .doFinally(                                       signalType -> clearAfterClient( userInformation , adminDataModel , routeChange ,                                                                       flightChange ) )                               .blockLast();                            break;                        case Read:                            clientsLock.writeLock().lock();                            connectedClients.add( userInformation.getLogin() );                            clientsLock.writeLock().unlock();                            Path cachingPath = Paths.get(                                    basesCacheFiles + optionalBase.get().getKey().getName() + "_" +                                    optionalBase.get().getValue().getLogin() );                            Optional<Path> cachingFile = Files.lines( cachingPath ).map( Paths::get ).findFirst();                            if( cachingFile.isPresent() ){                                outputStream.writeUTF( mapper.writeValueAsString( new Data( Files.lines( cachingPath )                                                                                                 .map( ListChangeAdapter::new )                                                                                                 .collect(                                                                                                         Collectors.toList() ) ) ) );                                Files.write( cachingFile.get() , "".getBytes() );                            }else{                                DataModelWithLockAndListener clientDataModel =                                        DataModelInstanceSaver.getInstance( userInformation.getDataBase() )                                                              .orElseThrow( IllegalStateException::new );                                Files.createFile( cachingPath );                                outputStream.writeUTF( mapper.writeValueAsString(                                        getStartingData( userInformation , clientDataModel.getModel() ) ) );                            }                            clientsLock.writeLock().lock();                            connectedClients.remove( userInformation.getLogin() );                            clientsLock.writeLock().unlock();                            closeConnection();                            break;                    }                }else{                    sendError( new FaRWrongDataBase( String.format( "Server doesn't contain database %s for user %s" ,                                                                    userInformation.getDataBase() ,                                                                    userInformation.getLogin() ) ) );                    closeConnection();                }            }catch( IOException e ){                e.printStackTrace();            }        }        private void clearAfterClient( UserInformation userInformation , DataModelWithLockAndListener dataModel ,                                       ListChangeListener<Route> routeChange ,                                       ListChangeListener<Flight> flightChange ){            dataModel.getModel().removeRoutesListener( routeChange );            dataModel.getModel().removeFlightsListener( flightChange );            connectedAdmins.remove( userInformation.getLogin() );            closeConnection();        }        private void listenUpdateFromClients( FluxSink<String> emitter ){            try{                String req;                while( !( req = inputStream.readUTF() ).equals( "*" ) ){                    emitter.next( req );                }                emitter.complete();            }catch( EOFException e ){                emitter.complete();            }catch( IOException e ){                emitter.error( e );            }        }        /**         Returns database, that user has requested with his privileges. Optional empty if settings file doesn't         contain specified database         @param userInformation user request info         @return Optional.of(Base , User) , if user and base info is right, Optional.empty() instead         */        private Optional<Pair<Base, User>> getDatabaseWithUser( UserInformation userInformation ){            return settings.getBase()                           .parallelStream()                           .filter( base -> base.getName().equals( userInformation.getDataBase() ) )                           .map( base -> getFirstBaseWithSpecifiedUser( base , userInformation.getLogin() ,                                                                        userInformation.getPassword() ) )                           .filter( pair -> pair.getValue().isPresent() )                           .map( pair -> new Pair<>( pair.getKey() , pair.getValue().get() ) )                           .findFirst();        }        @NotNull        private Pair<Base, Optional<User>> getFirstBaseWithSpecifiedUser( Base base , String login , String password ){            return new Pair<>( base , base.getUsers()                                          .parallelStream()                                          .filter( user -> userPredicate( user , login , password ) )                                          .findFirst() );        }        private Data databasesListRequest( UserInformation userInformation ){            Data response = new Data();//            collecting databases with privileges of specified client            response.setBases( settings.getBase()                                       .parallelStream()                                       .map( base -> getFirstBaseWithSpecifiedUser( base , userInformation.getLogin() ,                                                                                    userInformation.getPassword() ) )                                       .filter( pair -> pair.getValue().isPresent() )                                       .map( pair -> new Pair<>( pair.getKey().getName() ,                                                                 pair.getValue().get().getPrivilege().name() ) )                                       .collect( Collectors.toMap( Pair::getKey , Pair::getValue ) ) );            return response;        }        private void sendError( FlightAndRouteException e ){            try{                Data response = new Data();                response.setException( new FaRIllegalDataException( e.getMessage() , e.getCause() ) );                outputStream.writeUTF( mapper.writeValueAsString( response ) );            }catch( IOException e1 ){                e1.printStackTrace();            }        }        private void closeConnection(){            try{                outputStream.close();                inputStream.close();                socket.close();            }catch( IOException e ){                e.printStackTrace();            }        }        private void sendChange( ListChangeAdapter adapter ){            Data data = new Data();            data.setChanges( Collections.singletonList( adapter ) );            connectedAdmins.entrySet()                           .stream()                           .map( entry -> ( DataOutputStream ) entry.getValue() )                           .forEach( outputStream -> {                               try{                                   outputStream.writeUTF( mapper.writeValueAsString( data ) );                               }catch( IOException e ){                                   e.printStackTrace();                               }                           } );        }        private boolean userPredicate( User user , String login , String password ){            return user.getLogin().equals( login ) && user.getPassword().equals( password );        }    }    @NotNull    private static Data getStartingData( UserInformation userInformation , DataModel dataModel ){        //noinspection unchecked        return new Data( dataModel.listRoutesWithPredicate(                Optional.ofNullable( ( Predicate<Route> ) userInformation.getPredicate() ).orElse( route -> true ) ) ,                         dataModel.listFlightsWithPredicate(                                 Optional.ofNullable( ( Predicate<Flight> ) userInformation.getPredicate() )                                         .orElse( flight -> true ) ) );    }}