package server;import com.fasterxml.jackson.databind.ObjectMapper;import settings.Base;import settings.Settings;import settings.SettingsManager;import settings.User;import transport.Data;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.locks.ReentrantReadWriteLock;import java.util.function.Predicate;import java.util.stream.Collectors;public class Server{    public static Settings settings;    static{        settings = SettingsManager.loadSettings();    }    static ReentrantReadWriteLock    loginsLock      = new ReentrantReadWriteLock( true );    static List<String>              connectedLogins = new ArrayList<>();    static ReentrantReadWriteLock    adminsLock      = new ReentrantReadWriteLock( true );    static Map<String, List<Socket>> admins          = new ConcurrentHashMap<>();    @SuppressWarnings( "InfiniteLoopStatement" )    public static void main( String[] args ) throws IOException{        int port = Integer.parseInt( args[ 0 ] );        try( ServerSocket requestServerSocket = new ServerSocket( port ) ; ){//            Request threads            ExecutorService requestService = Executors.newCachedThreadPool();            while( true ){                requestService.execute( new RequestParser( requestServerSocket.accept() ) );            }        }    }    static class RequestParser implements Runnable{        private final Socket           socket;        private       DataInputStream  inputStream;        private       DataOutputStream outputStream;        private ObjectMapper mapper = new ObjectMapper();        RequestParser( Socket socket ) throws IOException{            this.socket = socket;            try{                this.outputStream = new DataOutputStream( socket.getOutputStream() );                this.inputStream = new DataInputStream( socket.getInputStream() );            }catch( IOException e ){                e.printStackTrace();                socket.close();            }        }        @Override        public void run(){        }        private void databasesListRequest( String login , String pass ){            Predicate<User> predicate = user -> user.getName().equals( login ) && user.getPassword().equals( pass );            Data            response  = new Data();            response.setBases( settings.getBase()                                       .stream()                                       .filter( base -> base.getUser().stream().anyMatch( predicate ) )                                       .collect( Collectors.toMap( Base::getName , base -> base.getUser()                                                                                               .stream()                                                                                               .filter( predicate )                                                                                               .findFirst()                                                                                               .orElseThrow(                                                                                                       IllegalStateException::new )                                                                                               .getPrivilege()                                                                                               .name() ) ) );        }    }}