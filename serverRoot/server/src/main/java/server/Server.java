package server;import com.fasterxml.jackson.databind.ObjectMapper;import exceptions.FaRAlreadyConnectedClient;import exceptions.FaRIllegalDataException;import exceptions.FaRWrongDataBase;import exceptions.FlightAndRouteException;import javafx.collections.ListChangeListener;import javafx.util.Pair;import model.*;import org.jetbrains.annotations.NotNull;import reactor.core.publisher.Flux;import reactor.core.publisher.FluxSink;import settings.Base;import settings.Settings;import settings.SettingsManager;import settings.User;import transport.Data;import transport.ListChangeAdapter;import transport.PredicateParser;import transport.UserInformation;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.time.Duration;import java.time.Instant;import java.time.LocalDateTime;import java.time.ZoneId;import java.util.*;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.locks.ReentrantReadWriteLock;import java.util.function.Predicate;import java.util.stream.Collectors;import static settings.SettingsManager.basesCacheFiles;public class Server{    public static final Settings settings;    //    contains all login of connected read clients    private static final List<String>              connectedClients = new ArrayList<>();    private static final ReentrantReadWriteLock    clientsLock      = new ReentrantReadWriteLock( true );    //    contains all connectedAdmins with their socket who is already connected    private static final Map<String, OutputStream> connectedAdmins  = new ConcurrentHashMap<>();    private static final ReentrantReadWriteLock    adminsLock       = new ReentrantReadWriteLock( true );    @SuppressWarnings( "FieldCanBeLocal" ) private static Integer port;    @SuppressWarnings( "FieldCanBeLocal" ) private static Integer stoppingPort;    static{        settings = SettingsManager.loadSettings();    }    @SuppressWarnings( "InfiniteLoopStatement" )    public static void main( String[] args ) throws IOException{        port = Integer.parseInt( args[ 0 ] );//        handler stop server action from settings app        stoppingPort = Integer.parseInt( args[ 1 ] );        AtomicBoolean           stopped        = new AtomicBoolean( false );        AtomicReference<Socket> stoppingSocket = new AtomicReference<>( new Socket() );        Executors.newSingleThreadExecutor().submit( () -> {            try( ServerSocket serverSocket = new ServerSocket( stoppingPort ) ){                stoppingSocket.set( serverSocket.accept() );                stopped.set( true );            }catch( IOException e ){                e.printStackTrace();            }        } );        try( ServerSocket requestServerSocket = new ServerSocket( port ) ){//            Cleaning old cache files            Executors.newSingleThreadScheduledExecutor( r -> {                Thread thread = new Thread( r );                thread.setDaemon( true );                return thread;            } ).scheduleAtFixedRate( () -> {                try{                    Files.list( Paths.get( basesCacheFiles ) ).filter( Server::isLastAgoModified ).forEach( path -> {                        try{                            Files.delete( path );                        }catch( IOException e ){                            e.printStackTrace();                        }                    } );                }catch( IOException e ){                    e.printStackTrace();                }            } , 1 , 1 , TimeUnit.SECONDS );//            Request threads            ExecutorService requestService = Executors.newCachedThreadPool();            while( true ){//                Server stops only after new connection                if( stopped.get() ){                    try( DataOutputStream dataOutputStream = new DataOutputStream( stoppingSocket.get()                                                                                                 .getOutputStream() ) ){                        dataOutputStream.writeUTF( "Server stopped" );                    }                    System.exit( 0 );                }                requestService.execute( new RequestParser( requestServerSocket.accept() ) );            }        }    }    //    Check if client's cache file ives in storage more then 1 day    private static boolean isLastAgoModified( Path path ){        return Duration.between( LocalDateTime.ofInstant( Instant.ofEpochMilli( path.toFile().lastModified() ) ,                                                          ZoneId.systemDefault() ) , LocalDateTime.now() ).toDays() >=               1;    }    @NotNull    private static Data getStartingData( UserInformation userInformation , DataModel dataModel ){        //noinspection unchecked        return new Data( dataModel.getRouteObservableList()                                  .stream()                                  .filter( Optional.ofNullable( userInformation.getPredicate() )                                                   .map( PredicateParser::getRoutePredicate )                                                   .orElse( route -> true ) )                                  .collect( Collectors.toList() ) ,                         dataModel.getFlightObservableList()                                  .stream()                                  .filter( Optional.ofNullable( userInformation.getPredicate() )                                                   .map( PredicateParser::getFlightPredicate )                                                   .orElse( flight -> true ) )                                  .collect( Collectors.toList() ) );    }    static class RequestParser implements Runnable{        private final Socket socket;        private final ObjectMapper mapper = new ObjectMapper();        private DataInputStream  inputStream;        private DataOutputStream outputStream;        RequestParser( Socket socket ) throws IOException{            this.socket = socket;            try{                this.outputStream = new DataOutputStream( socket.getOutputStream() );                this.inputStream = new DataInputStream( socket.getInputStream() );            }catch( IOException e ){                e.printStackTrace();                socket.close();            }        }        @Override        public void run(){            try{                UserInformation userInformation =                        mapper.readerFor( UserInformation.class ).readValue( inputStream.readUTF() );//                Request for bases list                if( userInformation.getDataBase() == null ){                    outputStream.writeUTF( mapper.writeValueAsString( databasesListRequest( userInformation ) ) );                    closeConnection();                    return;                }//                finding any database with specified user                Optional<Pair<Base, User>> optionalBase = getDatabaseWithUser( userInformation );                if( optionalBase.isPresent() ){                    clientsLock.readLock().lock();                    boolean alreadyConnected =                            connectedClients.stream().anyMatch( Predicate.isEqual( userInformation.getLogin() ) );                    clientsLock.readLock().unlock();                    if( alreadyConnected ){                        /* Refuse client's request, if the same login already works with server                         * Admins can make several connections for server*/                        sendError( new FaRAlreadyConnectedClient( String.format(                                "Client %s is already connected. Connection refused." ,                                userInformation.getLogin() ) ) );                        closeConnection();                        return;                    }                    switch( optionalBase.get().getValue().getPrivilege() ){                        case ReadWrite:                            adminsLock.writeLock().lock();                            connectedAdmins.put( userInformation.getLogin() , outputStream );                            adminsLock.writeLock().unlock();                            DataModelWithLockAndListener adminDataModel =                                    DataModelInstanceSaver.getInstance( optionalBase.get().getKey().getName() )                                                          .orElseThrow( IllegalStateException::new );                            outputStream.writeUTF( mapper.writeValueAsString( getStartingData( userInformation ,                                                                                               adminDataModel.getModel() ) ) );                            ListChangeListener<Route> routeChange =                                    change -> sendChange( ListChangeAdapter.routeChange( change ) );                            ListChangeListener<Flight> flightChange =                                    change -> sendChange( ListChangeAdapter.flightChange( change ) );                            adminDataModel.getModel().addRoutesListener( routeChange );                            adminDataModel.getModel().addFlightsListener( flightChange );                            Flux.create( this::listenUpdateFromClients )                                .map( this::userRequestToUserInformation )                                .map( UserInformation::getChanges )                                .doOnNext( listChanges -> listChanges.forEach( change -> {                                    try{                                        change.apply( adminDataModel.getModel() );                                    }catch( FlightAndRouteException e ){                                        sendError( e );                                    }                                } ) )                                .doFinally( signalType -> cleatAfterAdmin( userInformation ,                                                                           adminDataModel ,                                                                           routeChange ,                                                                           flightChange ) )                                .blockLast();                            break;                        case Read:                            clientsLock.writeLock().lock();                            connectedClients.add( userInformation.getLogin() );                            clientsLock.writeLock().unlock();                            Path cachingDirectoryPath = Paths.get( basesCacheFiles );                            Optional<Path> cachingFile = Files.list( cachingDirectoryPath )                                                              .filter( path -> path.endsWith( optionalBase.get()                                                                                                          .getKey()                                                                                                          .getName() +                                                                                              "_" +                                                                                              optionalBase.get()                                                                                                          .getValue()                                                                                                          .getLogin() ) )                                                              .findFirst();                            if( cachingFile.isPresent() ){                                outputStream.writeUTF( mapper.writeValueAsString( new Data( Files.lines( cachingFile.get() )                                                                                                 .map( ListChangeAdapter::new )                                                                                                 .collect( Collectors.toList() ) ) ) );                                Files.write( cachingFile.get() , "".getBytes() );                            }else{                                DataModelWithLockAndListener clientDataModel =                                        DataModelInstanceSaver.getInstance( userInformation.getDataBase() )                                                              .orElseThrow( IllegalStateException::new );                                Files.createFile( Paths.get( basesCacheFiles +                                                             optionalBase.get().getKey().getName() +                                                             "_" +                                                             optionalBase.get().getValue().getLogin() ) );                                outputStream.writeUTF( mapper.writeValueAsString( getStartingData( userInformation ,                                                                                                   clientDataModel.getModel() ) ) );                            }                            clientsLock.writeLock().lock();                            connectedClients.remove( userInformation.getLogin() );                            clientsLock.writeLock().unlock();                            closeConnection();                            break;                    }                }else{                    sendError( new FaRWrongDataBase( String.format( "Server doesn't contain database %s for user %s" ,                                                                    userInformation.getDataBase() ,                                                                    userInformation.getLogin() ) ) );                    closeConnection();                }            }catch( IOException e ){                e.printStackTrace();            }        }        private void cleatAfterAdmin( UserInformation userInformation , DataModelWithLockAndListener adminDataModel ,                                      ListChangeListener<Route> routeChange , ListChangeListener<Flight> flightChange ){            adminDataModel.getModel().removeRoutesListener( routeChange );            adminDataModel.getModel().removeFlightsListener( flightChange );            connectedAdmins.remove( userInformation.getLogin() );            closeConnection();        }        private UserInformation userRequestToUserInformation( String string ){            try{                return mapper.readerFor( UserInformation.class ).readValue( string );            }catch( IOException e ){                throw new IllegalStateException( "Exception while reading info from user" );            }        }        private void listenUpdateFromClients( FluxSink<String> emitter ){            try{                String req;                while( !( req = inputStream.readUTF() ).equals( "*" ) ){                    emitter.next( req );                }                emitter.complete();            }catch( EOFException e ){                emitter.complete();            }catch( IOException e ){                emitter.error( e );            }        }        /**         Returns database, that user has requested with his privileges. Optional empty if settings file doesn't         contain specified database         @param userInformation user request info         @return Optional.of(Base , User) , if user and base info is right, Optional.empty() instead         */        private Optional<Pair<Base, User>> getDatabaseWithUser( UserInformation userInformation ){            return settings.getBase()                           .parallelStream()                           .filter( base -> base.getName().equals( userInformation.getDataBase() ) )                           .map( base -> getFirstBaseWithSpecifiedUser( base ,                                                                        userInformation.getLogin() ,                                                                        userInformation.getPassword() ) )                           .filter( pair -> pair.getValue().isPresent() )                           .map( pair -> new Pair<>( pair.getKey() , pair.getValue().get() ) )                           .findFirst();        }        @NotNull        private Pair<Base, Optional<User>> getFirstBaseWithSpecifiedUser( Base base , String login , String password ){            return new Pair<>( base ,                               base.getUsers()                                   .parallelStream()                                   .filter( user -> userPredicate( user , login , password ) )                                   .findFirst() );        }        private Data databasesListRequest( UserInformation userInformation ){            Data response = new Data();//            collecting databases with privileges of specified client            response.setBases( settings.getBase()                                       .parallelStream()                                       .map( base -> getFirstBaseWithSpecifiedUser( base ,                                                                                    userInformation.getLogin() ,                                                                                    userInformation.getPassword() ) )                                       .filter( pair -> pair.getValue().isPresent() )                                       .map( pair -> new Pair<>( pair.getKey().getName() ,                                                                 pair.getValue().get().getPrivilege().name() ) )                                       .collect( Collectors.toMap( Pair::getKey , Pair::getValue ) ) );            return response;        }        private void sendError( FlightAndRouteException e ){            try{                Data response = new Data();                response.setException( new FaRIllegalDataException( e.getMessage() , e.getCause() ) );                outputStream.writeUTF( mapper.writeValueAsString( response ) );            }catch( IOException e1 ){                e1.printStackTrace();            }        }        private void closeConnection(){            try{                outputStream.close();                inputStream.close();                socket.close();            }catch( IOException e ){                e.printStackTrace();            }        }        private void sendChange( ListChangeAdapter adapter ){            Data data = new Data();            data.setChanges( Collections.singletonList( adapter ) );            adminsLock.readLock().lock();//            Send changes to all admins            connectedAdmins.entrySet()                           .stream()                           .map( Map.Entry::getValue )                           .map( DataOutputStream.class::cast )                           .forEach( outputStream -> {                               try{                                   outputStream.writeUTF( mapper.writeValueAsString( data ) );                               }catch( IOException e ){                                   e.printStackTrace();                               }                           } );            adminsLock.readLock().unlock();        }        private boolean userPredicate( User user , String login , String password ){            return user.getLogin().equals( login ) && user.getPassword().equals( password );        }    }}